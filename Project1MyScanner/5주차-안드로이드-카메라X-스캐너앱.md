# 5주차: Android CameraX를 이용한 스캐너 앱 개발

## 실무이론 (10분)

### CameraX API 개요
- **CameraX**: Android Jetpack의 카메라 라이브러리
- **주요 장점**: 기존 Camera2 API보다 간단한 사용법, 자동 최적화, 안정성 향상
- **지원 버전**: Android 5.0 (API 21) 이상

### CameraX 핵심 컴포넌트
- **Preview**: 카메라 뷰파인더 화면 표시
- **ImageCapture**: 사진 촬영 및 저장
- **ImageAnalysis**: 실시간 이미지 분석 (미사용)
- **ProcessCameraProvider**: 카메라 생명주기 관리

### 권한 및 보안 시스템
- **런타임 권한**: Android 6.0+ 동적 권한 요청
- **Scoped Storage**: Android 10+ 파일 접근 제한
- **FileProvider**: 안전한 파일 공유 메커니즘

## 과제이론 (20분)

### 1. CameraX 의존성 설정

#### build.gradle.kts 설정
```kotlin
// CameraX dependencies
val cameraxVersion = "1.4.2"
implementation("androidx.camera:camera-core:$cameraxVersion")
implementation("androidx.camera:camera-camera2:$cameraxVersion")
implementation("androidx.camera:camera-lifecycle:$cameraxVersion")
implementation("androidx.camera:camera-view:$cameraxVersion")

// 추가 라이브러리
implementation("androidx.exifinterface:exifinterface:1.3.7")  // 이미지 회전 정보
implementation("com.github.bumptech.glide:glide:4.16.0")    // 이미지 로딩
```

#### AndroidManifest.xml 권한 설정
```xml
<!-- 카메라 기능 필수 -->
<uses-feature android:name="android.hardware.camera.any" />
<uses-permission android:name="android.permission.CAMERA" />

<!-- 저장소 권한 (API 32 이하에서만) -->
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
    android:maxSdkVersion="32" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"
    android:maxSdkVersion="32" />

<!-- Intent 쿼리 선언 -->
<queries>
    <intent>
        <action android:name="android.media.action.IMAGE_CAPTURE" />
    </intent>
</queries>
```

### 2. 런타임 권한 처리

#### MainActivity.kt - 권한 요청 구현
```kotlin
class MainActivity : AppCompatActivity() {
    
    // ActivityResultContracts 사용한 권한 요청
    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val allGranted = permissions.all { it.value }
        if (allGranted) {
            openCameraActivity()
        } else {
            Toast.makeText(this, "권한이 필요합니다.", Toast.LENGTH_SHORT).show()
        }
    }
    
    private fun checkPermissionsAndOpenCamera() {
        val permissions = mutableListOf(Manifest.permission.CAMERA)
        
        // Android 10 미만에서만 저장소 권한 필요
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
            permissions.add(Manifest.permission.WRITE_EXTERNAL_STORAGE)
        }
        
        val allPermissionsGranted = permissions.all { permission ->
            ContextCompat.checkSelfPermission(this, permission) == 
                PackageManager.PERMISSION_GRANTED
        }
        
        if (allPermissionsGranted) {
            openCameraActivity()
        } else {
            requestPermissionLauncher.launch(permissions.toTypedArray())
        }
    }
}
```

### 3. CameraX 초기화 및 설정

#### CameraActivity.kt - 카메라 초기화
```kotlin
class CameraActivity : AppCompatActivity() {
    
    private lateinit var cameraExecutor: ExecutorService
    private var imageCapture: ImageCapture? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        binding = ActivityCameraBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        // 백그라운드 스레드 생성
        cameraExecutor = Executors.newSingleThreadExecutor()
        
        setupFullScreen()  // 전체 화면 설정
        startCamera()      // 카메라 시작
    }
    
    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        
        cameraProviderFuture.addListener({
            val cameraProvider = cameraProviderFuture.get()
            
            // Preview 설정
            val preview = Preview.Builder().build().also {
                it.surfaceProvider = binding.previewView.surfaceProvider
            }
            
            // ImageCapture 설정
            imageCapture = ImageCapture.Builder()
                .setCaptureMode(ImageCapture.CAPTURE_MODE_MAXIMIZE_QUALITY)
                .setTargetRotation(windowManager.defaultDisplay.rotation)
                .build()
            
            // 카메라 바인딩
            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA
            
            try {
                cameraProvider.unbindAll()
                camera = cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview, imageCapture
                )
            } catch (exc: Exception) {
                Log.e(TAG, "카메라 바인딩 실패", exc)
            }
            
        }, ContextCompat.getMainExecutor(this))
    }
}
```

### 4. 전체 화면 UI 구현

#### 몰입형 전체 화면 설정
```kotlin
private fun setupFullScreen() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
        // Android 11+ 새로운 API
        window.setDecorFitsSystemWindows(false)
        window.insetsController?.let {
            it.hide(WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars())
            it.systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
        }
    } else {
        // 이전 버전 호환
        @Suppress("DEPRECATION")
        window.decorView.systemUiVisibility = (
            View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
            or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
            or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
        )
    }
    
    // 화면 켜짐 유지
    window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
}
```

### 5. 이미지 촬영 및 저장

#### 사진 촬영 구현
```kotlin
private fun takePhoto() {
    val imageCapture = imageCapture ?: return
    
    // 파일명 생성 (날짜 기반)
    val name = SimpleDateFormat("yyyy-MM-dd-HHmmss", Locale.KOREA)
        .format(System.currentTimeMillis())
    
    // 앱 내부 저장소에 폴더 생성
    val photosDir = File(filesDir, "photos")
    if (!photosDir.exists()) {
        photosDir.mkdirs()
    }
    
    val photoFile = File(photosDir, "$name.jpg")
    val outputOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()
    
    // 사진 촬영 실행
    imageCapture.takePicture(
        outputOptions,
        ContextCompat.getMainExecutor(this),
        object : ImageCapture.OnImageSavedCallback {
            override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                correctImageOrientation(photoFile)  // 회전 보정
                saveToMediaStore(photoFile)          // MediaStore 저장
                
                Toast.makeText(this@CameraActivity, "저장완료", Toast.LENGTH_SHORT).show()
                
                // 결과 반환
                val resultIntent = Intent().apply {
                    putExtra("photo_path", photoFile.absolutePath)
                }
                setResult(RESULT_OK, resultIntent)
                finish()
            }
            
            override fun onError(exception: ImageCaptureException) {
                Log.e(TAG, "촬영 실패: ${exception.message}", exception)
            }
        }
    )
}
```

### 6. 이미지 회전 보정

#### EXIF 데이터를 이용한 자동 회전
```kotlin
private fun correctImageOrientation(photoFile: File) {
    try {
        val exif = ExifInterface(photoFile.absolutePath)
        val orientation = exif.getAttributeInt(
            ExifInterface.TAG_ORIENTATION,
            ExifInterface.ORIENTATION_NORMAL
        )
        
        val bitmap = BitmapFactory.decodeFile(photoFile.absolutePath)
        val rotatedBitmap = when (orientation) {
            ExifInterface.ORIENTATION_ROTATE_90 -> rotateBitmap(bitmap, 90f)
            ExifInterface.ORIENTATION_ROTATE_180 -> rotateBitmap(bitmap, 180f)
            ExifInterface.ORIENTATION_ROTATE_270 -> rotateBitmap(bitmap, 270f)
            else -> bitmap
        }
        
        // 회전된 이미지 다시 저장
        if (rotatedBitmap != bitmap) {
            FileOutputStream(photoFile).use { out ->
                rotatedBitmap.compress(Bitmap.CompressFormat.JPEG, 95, out)
            }
            rotatedBitmap.recycle()
        }
        bitmap.recycle()
        
    } catch (e: Exception) {
        Log.e(TAG, "회전 보정 실패", e)
    }
}

private fun rotateBitmap(bitmap: Bitmap, degrees: Float): Bitmap {
    val matrix = Matrix().apply { postRotate(degrees) }
    return Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
}
```

### 7. MediaStore를 통한 갤러리 저장

#### Android 10+ Scoped Storage 대응
```kotlin
private fun saveToMediaStore(photoFile: File) {
    try {
        val contentValues = ContentValues().apply {
            put(MediaStore.MediaColumns.DISPLAY_NAME, photoFile.name)
            put(MediaStore.MediaColumns.MIME_TYPE, "image/jpeg")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.MediaColumns.RELATIVE_PATH, "Pictures/MyScanner")
            }
        }
        
        val uri = contentResolver.insert(
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
            contentValues
        )
        
        uri?.let {
            contentResolver.openOutputStream(it)?.use { outputStream ->
                photoFile.inputStream().use { inputStream ->
                    inputStream.copyTo(outputStream)
                }
            }
        }
    } catch (e: Exception) {
        Log.e(TAG, "MediaStore 저장 실패", e)
    }
}
```

## 과제피드백 (20분)

### 자주 발생하는 오류와 해결책

#### 1. 카메라 권한 거부 시 처리
- **문제**: 권한 거부 시 앱이 비정상 종료되거나 기능 사용 불가
- **해결**: 권한 상태 확인 후 적절한 사용자 안내 메시지 표시

```kotlin
// 권한 거부 시 재시도 안내
private fun showPermissionExplanation() {
    AlertDialog.Builder(this)
        .setTitle("권한 필요")
        .setMessage("카메라 기능을 사용하려면 권한이 필요합니다.")
        .setPositiveButton("설정으로 이동") { _, _ ->
            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
            intent.data = Uri.fromParts("package", packageName, null)
            startActivity(intent)
        }
        .setNegativeButton("취소", null)
        .show()
}
```

#### 2. 메모리 부족으로 인한 앱 크래시
- **문제**: 고해상도 이미지 처리 시 OutOfMemoryError 발생
- **해결**: Bitmap 메모리 관리 및 적절한 이미지 크기 조정

```kotlin
// 메모리 효율적인 이미지 처리
private fun processImageSafely(photoFile: File) {
    val options = BitmapFactory.Options().apply {
        inJustDecodeBounds = true  // 메타데이터만 읽기
    }
    
    BitmapFactory.decodeFile(photoFile.absolutePath, options)
    
    // 화면 크기에 맞게 이미지 스케일 계산
    val scaleFactor = calculateInSampleSize(options, 1080, 1920)
    
    options.apply {
        inJustDecodeBounds = false
        inSampleSize = scaleFactor
    }
    
    val bitmap = BitmapFactory.decodeFile(photoFile.absolutePath, options)
    // ... 이미지 처리
    bitmap?.recycle()  // 메모리 해제
}
```

#### 3. 카메라 초기화 실패
- **문제**: 일부 기기에서 카메라 바인딩 실패
- **해결**: Try-catch 블록과 적절한 오류 처리

```kotlin
private fun bindCameraUseCases() {
    try {
        cameraProvider.unbindAll()
        
        camera = cameraProvider.bindToLifecycle(
            this, cameraSelector, preview, imageCapture
        )
        
        // 터치 포커스 설정
        setupTouchToFocus()
        
    } catch (exc: Exception) {
        Log.e(TAG, "카메라 바인딩 실패", exc)
        
        // 사용자에게 알림
        Toast.makeText(
            this,
            "카메라 초기화에 실패했습니다. 앱을 재시작해주세요.",
            Toast.LENGTH_LONG
        ).show()
        
        // 메인 화면으로 돌아가기
        finish()
    }
}
```

#### 4. 이미지 회전 문제
- **문제**: 촬영된 이미지가 잘못된 방향으로 저장됨
- **해결**: EXIF 정보 기반 자동 회전 처리 및 디바이스 방향 고려

```kotlin
// 더 정확한 회전 처리
private fun getCorrectOrientation(photoFile: File): Int {
    val exif = ExifInterface(photoFile.absolutePath)
    return when (exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)) {
        ExifInterface.ORIENTATION_ROTATE_90 -> 90
        ExifInterface.ORIENTATION_ROTATE_180 -> 180
        ExifInterface.ORIENTATION_ROTATE_270 -> 270
        else -> 0
    }
}
```

#### 5. 파일 저장 경로 문제
- **문제**: Android 버전별 파일 저장 위치 차이
- **해결**: Android 10 이상에서는 앱별 전용 저장소 사용

```kotlin
private fun getAppPhotoDirectory(): File {
    // Android 10+ 에서는 앱 전용 저장소 사용
    val photosDir = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        File(getExternalFilesDir(Environment.DIRECTORY_PICTURES), "MyScanner")
    } else {
        File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), "MyScanner")
    }
    
    if (!photosDir.exists()) {
        photosDir.mkdirs()
    }
    
    return photosDir
}
```

### 성능 최적화 팁

#### 1. 카메라 리소스 관리
```kotlin
override fun onDestroy() {
    super.onDestroy()
    cameraExecutor.shutdown()  // 백그라운드 스레드 정리
}

override fun onPause() {
    super.onPause()
    // 카메라 일시 정지 (배터리 절약)
    camera?.cameraControl?.enableTorch(false)
}
```

#### 2. 이미지 메모리 최적화
```kotlin
// Glide를 이용한 효율적인 이미지 로딩
Glide.with(context)
    .load(photoFile)
    .override(300, 300)  // 크기 제한
    .centerCrop()
    .diskCacheStrategy(DiskCacheStrategy.ALL)  // 캐싱 전략
    .into(imageView)
```

## Q&A (10분)

### 자주 묻는 질문들

#### Q1: CameraX와 Camera2 API의 차이점은?
- **CameraX**: 간편한 사용법, 자동 최적화, 생명주기 관리 자동화
- **Camera2**: 세밀한 제어 가능, 복잡한 설정 필요, 수동 생명주기 관리

#### Q2: 전면 카메라로 전환하는 방법은?
```kotlin
// 전면/후면 카메라 전환
private fun switchCamera() {
    cameraSelector = if (cameraSelector == CameraSelector.DEFAULT_BACK_CAMERA) {
        CameraSelector.DEFAULT_FRONT_CAMERA
    } else {
        CameraSelector.DEFAULT_BACK_CAMERA
    }
    
    startCamera()  // 카메라 재시작
}
```

#### Q3: 촬영 시 셔터음을 제거할 수 있나요?
- **제한사항**: 법적 이유로 일부 국가(한국, 일본)에서는 셔터음 제거 불가
- **해결책**: 시스템 설정에서 사용자가 직접 음소거 설정

#### Q4: 이미지 품질을 더 높이려면?
```kotlin
imageCapture = ImageCapture.Builder()
    .setCaptureMode(ImageCapture.CAPTURE_MODE_MAXIMIZE_QUALITY)
    .setJpegQuality(95)  // JPEG 품질 설정 (0-100)
    .build()
```

#### Q5: 실시간 이미지 분석은 어떻게 구현하나요?
```kotlin
// ImageAnalysis 사용 사례 (추후 활용)
private fun setupImageAnalysis() {
    val imageAnalyzer = ImageAnalysis.Builder()
        .setTargetResolution(Size(1280, 720))
        .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
        .build()
        .also {
            it.setAnalyzer(cameraExecutor) { image ->
                // 이미지 분석 로직 (QR 코드, 텍스트 인식 등)
                processImageProxy(image)
                image.close()
            }
        }
    
    // 카메라 바인딩에 imageAnalyzer 추가
    camera = cameraProvider.bindToLifecycle(
        this, cameraSelector, preview, imageCapture, imageAnalyzer
    )
}
```